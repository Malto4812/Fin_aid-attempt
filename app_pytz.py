
"""
app.py - Financial Aid Project (Flask)
Single-file Flask application storing data in SQLite.
Author: Generated by ChatGPT (GPT-5 Thinking mini)
Notes:
 - For a production deployment, secure the admin password file and use environment variables.
 - Email sending is stubbed; configure SMTP settings to enable real emails (see commented section).
 - This app stores admin password in admin_password.txt (for the task requirement).
"""

from flask import Flask, render_template, request, redirect, url_for, flash, session, jsonify
import sqlite3
from datetime import datetime, timezone, timedelta
import pytz
import os

APP_DIR = os.path.dirname(__file__)
DB_PATH = os.path.join(APP_DIR, "database.db")
ADMIN_PASS_FILE = os.path.join(APP_DIR, "admin_password.txt")

# Flask setup
app = Flask(__name__)
app.secret_key = "dev-secret-key-change-this"  # change in production

# Helper: get current East Africa Time (Africa/Kampala)
def now_eat():
    return datetime.now(pytz.timezone("Africa/Nairobi"))

# Database helpers
def get_db_conn():
    conn = sqlite3.connect(DB_PATH, detect_types=sqlite3.PARSE_DECLTYPES)
    conn.row_factory = sqlite3.Row
    return conn

def init_db():
    conn = get_db_conn()
    cur = conn.cursor()
    # users table: stores PID, email, signup_count, created_at
    cur.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY,
        pid TEXT UNIQUE,
        email TEXT UNIQUE,
        signup_count INTEGER DEFAULT 0,
        created_at TIMESTAMP
    )
    """)
    # requests table: stores requests made by users. Do NOT store names/emails here (admin requirement).
    cur.execute("""
    CREATE TABLE IF NOT EXISTS requests (
        id INTEGER PRIMARY KEY,
        user_pid TEXT,
        event TEXT,
        amount_required REAL,
        willing_amount REAL,
        balance REAL,
        status TEXT DEFAULT 'qualified', -- 'qualified' or 'disqualified'
        created_at TIMESTAMP
    )
    """)
    # additional table to log admin messages sent to users
    cur.execute("""
    CREATE TABLE IF NOT EXISTS admin_messages (
        id INTEGER PRIMARY KEY,
        user_pid TEXT,
        message TEXT,
        sent_at TIMESTAMP
    )
    """)
    conn.commit()
    conn.close()

# Utility: compute next PID starting at PID000100 and increasing by 7
def next_pid():
    conn = get_db_conn()
    cur = conn.cursor()
    cur.execute("SELECT pid FROM users ORDER BY id DESC LIMIT 1")
    row = cur.fetchone()
    if not row:
        base = 100
    else:
        last = row["pid"]  # like PID000100
        try:
            n = int(last.replace("PID",""))
            base = n + 7
        except:
            base = 100
    pid = f"PID{base:06d}"
    conn.close()
    return pid

# Initialize DB and admin password file if missing
if not os.path.exists(DB_PATH):
    init_db()

if not os.path.exists(ADMIN_PASS_FILE):
    with open(ADMIN_PASS_FILE, "w") as f:
        f.write("admin123")  # default password for testing; change in production

# Routes serving static-like pages (templates correspond to user's provided HTML)
@app.route("/")
def index():
    return render_template("index.html")

# Login / signup page
@app.route("/login", methods=["GET","POST"])
def login_page():
    if request.method == "POST":
        # two forms use POST here: detect which by input names
        if "name" in request.form and "email" in request.form:
            # Sign-Up flow
            name = request.form.get("name").strip()  # not stored per privacy request but we accept it
            email = request.form.get("email").strip().lower()
            conn = get_db_conn()
            cur = conn.cursor()
            cur.execute("SELECT * FROM users WHERE email = ?", (email,))
            if cur.fetchone():
                conn.close()
                flash("An account with this email already exists.", "error")
                return redirect(url_for("login_page"))
            pid = next_pid()
            created_at = now_eat()
            cur.execute("INSERT INTO users (pid, email, signup_count, created_at) VALUES (?,?,?,?)",
                        (pid, email, 0, created_at))
            conn.commit()
            conn.close()
            # Normally you'd send the PID to the user's email. For testing we flash it.
            flash(f"Account created. Your ID is {pid}. (It would also be sent to {email} by email in production.)", "success")
            # Store the pid in session and redirect to honour code
            session["user_pid"] = pid
            return redirect(url_for("honour_code"))
        elif "parent_id" in request.form:
            # Login flow (by PID)
            pid = request.form.get("parent_id").strip().upper()
            conn = get_db_conn()
            cur = conn.cursor()
            cur.execute("SELECT * FROM users WHERE pid = ?", (pid,))
            row = cur.fetchone()
            conn.close()
            if row:
                session["user_pid"] = pid
                flash("Login successful.", "success")
                return redirect(url_for("honour_code"))
            else:
                flash("ID not recognized. Please check and try again.", "error")
                return redirect(url_for("login_page"))
    return render_template("login_page.html")

@app.route("/honour_code", methods=["GET","POST"])
def honour_code():
    if "user_pid" not in session:
        flash("Please log in first.", "error")
        return redirect(url_for("login_page"))
    if request.method == "POST":
        agree = request.form.get("agree")
        if agree == "yes":
            return redirect(url_for("form_page"))
        else:
            return redirect(url_for("honour_code_not_agreed"))
    return render_template("honour_code.html")

@app.route("/honour_code_not_agreed")
def honour_code_not_agreed():
    return render_template("honour_code_not_agreed_to.html")

@app.route("/form", methods=["GET","POST"])
def form_page():
    if "user_pid" not in session:
        flash("Please log in first.", "error")
        return redirect(url_for("login_page"))
    if request.method == "POST":
        # Gather form fields
        q1 = request.form.get("yes-no-1")
        q2 = request.form.get("yes-no-2")
        event = request.form.get("event")
        try:
            amount_required = float(request.form.get("amount"))
            willing_amount = float(request.form.get("willing_amount"))
        except:
            flash("Invalid amounts entered.", "error")
            return redirect(url_for("form_page"))
        # Business rules
        if q1 == "no":
            return render_template("child_not_willing.html")
        if q2 == "yes":
            return render_template("child_disciplinary.html")
        if event == "trip":
            # compare willing_amount to 20% of amount_required
            if willing_amount < 0.2 * amount_required:
                return render_template("amount_too_small.html")
        # Otherwise create request
        balance = amount_required - willing_amount
        pid = session["user_pid"]
        now = now_eat()
        conn = get_db_conn()
        cur = conn.cursor()
        cur.execute("""
            INSERT INTO requests (user_pid, event, amount_required, willing_amount, balance, status, created_at)
            VALUES (?,?,?,?,?, 'qualified', ?)
        """, (pid, event, amount_required, willing_amount, balance, now))
        # increment user's signup_count (we use it as request_count)
        cur.execute("UPDATE users SET signup_count = signup_count + 1 WHERE pid = ?", (pid,))
        conn.commit()
        conn.close()
        # Redirect to success page
        return render_template("request_success.html", balance=balance, pid=pid)
    return render_template("form.html")

# User dashboard (requires login)
@app.route("/dashboard")
def dashboard():
    if "user_pid" not in session:
        flash("Please log in first.", "error")
        return redirect(url_for("login_page"))
    pid = session["user_pid"]
    conn = get_db_conn()
    cur = conn.cursor()
    cur.execute("SELECT pid, email, signup_count, created_at FROM users WHERE pid = ?", (pid,))
    user = cur.fetchone()
    # fetch user's requests
    cur.execute("SELECT * FROM requests WHERE user_pid = ? ORDER BY created_at DESC", (pid,))
    requests_list = cur.fetchall()
    conn.close()
    return render_template("dashboard.html", user=user, requests=requests_list)

# Delete account (user)
@app.route("/delete_account", methods=["POST"])
def delete_account():
    if "user_pid" not in session:
        flash("Please log in first.", "error")
        return redirect(url_for("login_page"))
    pid = session["user_pid"]
    conn = get_db_conn()
    cur = conn.cursor()
    # delete requests then user
    cur.execute("DELETE FROM requests WHERE user_pid = ?", (pid,))
    cur.execute("DELETE FROM users WHERE pid = ?", (pid,))
    conn.commit()
    conn.close()
    session.pop("user_pid", None)
    flash("Your account and associated requests have been deleted.", "success")
    return redirect(url_for("index"))

# Logout
@app.route("/logout")
def logout():
    session.pop("user_pid", None)
    flash("Logged out.", "info")
    return redirect(url_for("index"))

# Admin login
@app.route("/admin_login", methods=["GET","POST"])
def admin_login():
    if request.method == "POST":
        password = request.form.get("password", "")
        # read admin password file
        try:
            with open(ADMIN_PASS_FILE, "r") as f:
                real = f.read().strip()
        except:
            real = ""
        if password == real:
            session["admin"] = True
            return redirect(url_for("admin_panel"))
        else:
            flash("Invalid admin password.", "error")
            return redirect(url_for("admin_login"))
    return render_template("admin_login.html")

# Admin panel
@app.route("/admin_panel")
def admin_panel():
    if not session.get("admin"):
        flash("Admin login required.", "error")
        return redirect(url_for("admin_login"))
    conn = get_db_conn()
    cur = conn.cursor()
    # Users table (with emails hidden in requests table per requirement: but admins can see emails in users table)
    cur.execute("SELECT pid, email, signup_count, created_at FROM users ORDER BY created_at DESC")
    users = cur.fetchall()
    # Requests table: do NOT include names/emails; include pid, event, amounts, balance, status, created_at
    cur.execute("SELECT id, user_pid, event, amount_required, willing_amount, balance, status, created_at FROM requests ORDER BY created_at DESC")
    requests = cur.fetchall()
    conn.close()
    return render_template("admin_panel.html", users=users, requests=requests)

# Admin: change qualification status (AJAX)
@app.route("/admin_update_status", methods=["POST"])
def admin_update_status():
    if not session.get("admin"):
        return jsonify({"ok": False, "error": "admin required"}), 403
    req_id = request.form.get("req_id")
    status = request.form.get("status")
    if status not in ("qualified","disqualified"):
        return jsonify({"ok": False, "error": "invalid status"}), 400
    conn = get_db_conn()
    cur = conn.cursor()
    cur.execute("UPDATE requests SET status = ? WHERE id = ?", (status, req_id))
    conn.commit()
    conn.close()
    return jsonify({"ok": True})

# Admin: delete user or request
@app.route("/admin_delete_user", methods=["POST"])
def admin_delete_user():
    if not session.get("admin"):
        flash("Admin login required.", "error")
        return redirect(url_for("admin_login"))
    pid = request.form.get("pid")
    conn = get_db_conn()
    cur = conn.cursor()
    cur.execute("DELETE FROM requests WHERE user_pid = ?", (pid,))
    cur.execute("DELETE FROM users WHERE pid = ?", (pid,))
    conn.commit()
    conn.close()
    flash(f"Deleted user {pid} and their requests.", "info")
    return redirect(url_for("admin_panel"))

@app.route("/admin_delete_request", methods=["POST"])
def admin_delete_request():
    if not session.get("admin"):
        flash("Admin login required.", "error")
        return redirect(url_for("admin_login"))
    req_id = request.form.get("req_id")
    conn = get_db_conn()
    cur = conn.cursor()
    cur.execute("DELETE FROM requests WHERE id = ?", (req_id,))
    conn.commit()
    conn.close()
    flash("Request deleted.", "info")
    return redirect(url_for("admin_panel"))

# Admin: send message to user (looks up email by PID and records message)
@app.route("/admin_send_message", methods=["POST"])
def admin_send_message():
    if not session.get("admin"):
        flash("Admin login required.", "error")
        return redirect(url_for("admin_login"))
    pid = request.form.get("pid")
    message = request.form.get("message","").strip()
    sent_at = now_eat()
    conn = get_db_conn()
    cur = conn.cursor()
    # find email
    cur.execute("SELECT email FROM users WHERE pid = ?", (pid,))
    row = cur.fetchone()
    if not row:
        flash("PID not found.", "error")
        conn.close()
        return redirect(url_for("admin_panel"))
    email = row["email"]
    # For production, you'd send an actual email here. For now we record the attempt.
    cur.execute("INSERT INTO admin_messages (user_pid, message, sent_at) VALUES (?,?,?)", (pid, message, sent_at))
    conn.commit()
    conn.close()
    flash(f"Message recorded and would be sent to {email} (email sending not configured).", "success")
    return redirect(url_for("admin_panel"))

# Expose a simple route to view admin_password (for test only) - REMOVE in production
@app.route("/admin_password_file")
def admin_password_file():
    # only accessible to admin
    if not session.get("admin"):
        flash("Admin login required.", "error")
        return redirect(url_for("admin_login"))
    try:
        with open(ADMIN_PASS_FILE,"r") as f:
            pwd = f.read().strip()
    except:
        pwd = ""
    return f"Admin password file contents (for testing): {pwd}"

if __name__ == "__main__":
    # For Render, listen on all interfaces and pick port from environment
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port)
